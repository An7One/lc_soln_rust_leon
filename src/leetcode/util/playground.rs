struct Solution;

/// @author: Leon
/// Time Complexity:    O(`len_s` ^ 3)
/// Space Complexity:
#[allow(dead_code)]
impl Solution {
    // pub fn f(s: String) -> Vec<Vec<usize>> {
    //     let len_s: usize = s.len();
    //     let mut ans: Vec<Vec<usize>> = Vec::new();
    //     for lo in 0..len_s - 1 {
    //         for hi in lo + 1..len_s {
    //             if Self::is_eligible(&s, lo, hi) {
    //                 ans.push(vec![lo, hi]);
    //             }
    //         }
    //     }
    //     ans
    // }

    // fn is_eligible(s: &str, lo: usize, hi: usize) -> bool {
    //     let sub_lo: &str = &s[0..lo];
    //     let sub_mid: &str = &s[lo..hi];
    //     let sub_hi: &str = &s[hi..];
    //     // to compare
    // }

    //          a
    //        /   \
    //      b   bc  bcd
}
